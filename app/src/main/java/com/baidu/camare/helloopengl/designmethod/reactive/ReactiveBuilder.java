package com.baidu.camare.helloopengl.designmethod.reactive;import android.os.Build;import android.support.annotation.RequiresApi;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.lang.reflect.Parameter;import java.lang.reflect.Type;public class ReactiveBuilder {   @RequiresApi(api = Build.VERSION_CODES.O)   public static void main(String [] args) {        ReactiveBuilder reactiveBuilder = new ReactiveBuilder();        reactiveBuilder.getMethod();   //     System.out.println(ReactiveBuilder.class);   }   @RequiresApi(api = Build.VERSION_CODES.O)   public void getMethod()  {       Class<?> mClass = null;//      HelloReactive data = new HelloReactive();//      Class clazz = data.getClass();//        Class clazz = HelloReactive.class;//        clazz.getName();//        System.out.println(clazz.getName().toString());// class的获取       try {           Class clazz  = Class.forName("com.baidu.camare.helloopengl.designmethod.reactive.HelloReactive");           Class clz = HelloReactive.Hello.class;           System.out.println(clazz.getName());           System.out.println(String[].class.getName());           System.out.println(int.class.getName());           System.out.println(" Inner Class name:"+clz.getName());           System.out.println(" Inner Class Canonical name:"+clz.getCanonicalName());           System.out.println(" Inner Class simple name:"+clz.getSimpleName());           System.out.println("Modifier(修饰符)"+clazz.getModifiers());           System.out.println("打印出一个类的所有修饰符 类名修饰符:"+ Modifier.toString(clz.getModifiers()));//           try {//               clazz.newInstance();//           } catch (InstantiationException e) {//               e.printStackTrace();//           } catch (IllegalAccessException e) {//               e.printStackTrace();//           }//           两者的区别就是 getDeclaredField() 获取的是 Class 中被 private 修饰的属性。//           getField() 方法获取的是非私有属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取。           Field field = null;           Field field1 = null;           try {               // 获取自身的所有的public属性，包括从父类继承下来的          //     field = clazz.getField("var3");               // 获取自身所有的属性，但不包括从父类继承下来的属性               field1 =clazz.getDeclaredField("var3");           } catch (NoSuchFieldException e) {               e.printStackTrace();           }      //     System.out.println("获取class的成员 被private修饰的属性："+field1);// 域的获取           // 获取类的所有属性           Field[] fields = clazz.getFields();           for (Field field2:fields){               System.out.println("Fields--" +field2);           }           Field[] fields1 = clazz.getDeclaredFields();           for (Field field2:fields1){               System.out.println("DeclaredFields--" +field2);           }// 获取方法 Method           // 类似与Field  获取自身所有的public方法  包括继承父类           Method[] methods = clazz.getMethods();           for (Method method:methods){               System.out.println("Methods--" +method);           }           // 获取自身所有的方法  不包括继承的父类的方法           Method[] methods1 = clazz.getDeclaredMethods();           for (Method method : methods1){               System.out.println("DeclaredMethods--" +method);           }         //  System.out.println("Method--"+clazz.getMethod("messageNumber",null));// 获取Constructor  因为Cons不能从父类继承           Constructor[] constructor = clazz.getConstructors();           for (Constructor constructor1 : constructor){               System.out.println("Constructor--"+ constructor1);           }           Constructor[] constructors = clazz.getDeclaredConstructors();           for (Constructor constructor1 :constructors){               System.out.println("DeclaredConstructors--"+ constructor1);           }//Field的操控            Field[] f = clazz.getDeclaredFields();           for (Field field2 :f){               System.out.println("-------------------");               System.out.println("Field :"+field2.getName());               System.out.println("Field type:"+field2.getType());               System.out.println("Field generic type:"+field2.getGenericType());           }//Field 内容的读取与赋值           Class cla = Class.forName("com.baidu.camare.helloopengl.designmethod.reactive.HelloReactive");           try {               // test  fuck up 要new新对象               HelloReactive a = new HelloReactive();               cla.newInstance();               Field field2 = cla.getField("b");               field2.getInt(a);               Field string = cla.getDeclaredField("var1");               //当isAccessible()的结果是false时不允许通过反射访问该字段               string.setAccessible(true);               //  obj类型需要强制转换               string.set(a,"Hello 我把var1 赋值为了这个");               String ab = (String) string.get(a);               //当该字段时private修饰时isAccessible()得到的值是false，必须要改成true才可以访问               System.out.println("reflection HelloReactive c:"+field2.getInt(a));               System.out.println("reflection HelloReactive ab:"+ab);               field2.setInt(a,60);               System.out.println("reflection HelloReactive c:"+field2.getInt(a));//Method 的操控               /**  Parameter                * // 获取参数名字                public String getName() {}                // 获取参数类型                public Class<?> getType() {}                // 获取参数的修饰符                public int getModifiers() {}                */               System.out.println("-------------------");               Method[] m = cla.getDeclaredMethods();               for (Method method :m){                   System.out.println("method name:"+method.getName());                   // 方法的参数                   Parameter[] paras = method.getParameters();                   for ( Parameter p : paras ) {                       System.out.println(" parameter :"+p.getName()+":"                               +p.getType().getName() +"："                               +Modifier.toString(p.getModifiers()));                   }                   Class[] pTypes = method.getParameterTypes();                   System.out.println("method para types:");                   for ( Class type : pTypes ) {                       System.out.println(" "+ type.getName());                   }                   Type[] gTypes = method.getGenericParameterTypes();                   System.out.println("method para generic types:");                   for ( Type type : gTypes ) {                       System.out.println(" "+ type);                   }                   // 获取返回值类型                   System.out.println("method 返回值类型:" + method.getReturnType());                   // 获取返回值类型包括泛型                   System.out.println("method 返回值类型包括泛型:" + method.getGenericReturnType());                   System.out.println("method 修饰符:" + Modifier.toString(method.getModifiers()));                   System.out.println("method 异常类型:" + method.getExceptionTypes());                   System.out.println("method 异常类型GenericException:" + method.getGenericExceptionTypes());                   System.out.println("==========================================");               }//Method 方法的执行  invoke                   Class c = HelloReactive.class;                   Class invoke = Class.forName("com.baidu.camare.helloopengl.designmethod.reactive.HelloReactive");                   invoke.newInstance();                   // 获取静态方法                   Method method = invoke.getDeclaredMethod("testStatic");                   method.setAccessible(true);                   method.invoke(null, null);               /**                * invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，                * 如果这个方法是一个静态方法，那么 objects 为 null，后面的可变参数 Object 对应的自然就是参数。                */                  // 获取普通的方法              //   Class cl = HelloReactive.class;                 HelloReactive helloReactive = new HelloReactive();                 Method normalMethod = invoke.getDeclaredMethod("add",int.class,int.class);                 normalMethod.setAccessible(true);                 int invoke1 = (int)normalMethod.invoke(helloReactive, 3, 5);                 System.out.println("nomal method invoke :" + invoke1);               // 获取会抛出异常的方法   这里抛出异常//                  Method me = c.getMethod("testException",null);//                  me.invoke(helloReactive,null);// Constructor 的操控// 在创建对象的时候  推荐Consttuctor                Constructor mCons = clazz.getConstructor(int.class);                 mCons.newInstance(10086);//反射中的数组               /**                * 数组本质上是一个 Class，而在 Class 中存在一个方法用来识别它是否为一个数组。Class.java                */             //  Class classes = Class.forName("com.baidu.camare.helloopengl.designmethod.reactive.HelloReactive.Shuzu");                 Class classes = HelloReactive.Shuzu.class;                 Field[] fields2 = classes.getDeclaredFields();                 for (Field field3 :fields2){                     Class<?> type = field3.getType();                     if (type.isArray()){                        // type.newInstance();                         System.out.println("是arry"+ field3.getName()+":--"+type.getName() );                         System.out.println("是arry"+type.getComponentType());                     }                 }               System.out.println("==========================================");// 反射中动态创建数组   反射创建数组是通过 Array.newInstance() 这个方法。//                 Field fd = classes.getField("cars");//              //   Class<?> type = fd.getType();//               int[] o = (int[]) Array.newInstance(int.class, 3);//               Array.set(o,2,3);//               Array.set(o,2,5);//               Array.set(o,1,5);//               fd.set(classes,o);//             // 读取数组//               int[] car = (int[]) fd.get("cars");//               for ( int i = 0;i < car.length;i++) {//                   System.out.println("array index "+i+" value:"+car[i]);//               }               //   type.newInstance(int.class,2,3);// 反射中的枚举 Enum               /**                * / 用来判定 Class 对象是不是枚举类型                Class.isEnum()                // 获取所有的枚举常量                Class.getEnumConstants()                // 判断一个 Field 是不是枚举常量                java.lang.reflect.Field.isEnumConstant()                */              Class emm = Class.forName("com.baidu.camare.helloopengl.designmethod.reactive.Emmmm");               boolean anEnum = emm.isEnum();               System.out.println("this is enum or not? :"+ anEnum);               Field fil = emm.getField("test");               System.out.println("this is enumConstant or not? :"+ fil.isEnumConstant());               Object[] enumConstants = emm.getEnumConstants();                for (Object object : enumConstants){                    System.out.println("this is EnumConstants :"+ object.toString());                }               System.out.println("==========================================");               Field[] declaredFields = emm.getDeclaredFields();                for (Field field3 :declaredFields){                    if (field3.isEnumConstant()){                        System.out.println("this is EnumConstants :"+ field3.getName());                    }else                        System.out.println("this is not EnumConstants :"+ field3.getName());                }                Class e = Meiju.class;                e.newInstance();                Field fi = e.getDeclaredField("em");                fi.setAccessible(true);                System.out.println("current filed is :"+ fi.getName());                Meiju meiju = new Meiju();                Emmmm Emmmm = (Emmmm) fi.get(meiju);               System.out.println("当前的枚举类型是 :"+ Emmmm);                fi.setAccessible(true);                fi.set(meiju, Emmmm.action);               System.out.println("current emm is :"+ meiju.getEm());//模拟练习           } catch (NoSuchFieldException e) {               e.printStackTrace();           }catch (IllegalAccessException e) {               e.printStackTrace();           }catch (InstantiationException e){               e.printStackTrace();           }catch (NoSuchMethodException e){               e.printStackTrace();           }catch (InvocationTargetException e){           //    e.getCause();               System.out.println("Error message is :"+e.getCause().getMessage());           }       } catch (ClassNotFoundException e) {           e.printStackTrace();       }   }}